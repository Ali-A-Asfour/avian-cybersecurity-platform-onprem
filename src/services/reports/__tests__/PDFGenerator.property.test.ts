/**
 * Property-Based Tests for PDF Generator Service
 * 
 * Tests PDF export integrity using property-based testing.
 * Validates Requirements 8.1, 8.2, 8.3, 8.5
 */

import * as fc from 'fast-check';
import { PDFGenerator } from '../PDFGenerator';
import { ReportSnapshot, ChartData } from '@/types/reports';
import { generators } from './generators';

// Mock logger
jest.mock('@/lib/logger', () => ({
    logger: {
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn()
    }
}));

// Mock TemplateEngine
jest.mock('../TemplateEngine', () => ({
    TemplateEngine: jest.fn().mockImplementation(() => ({
        renderSlide: jest.fn().mockResolvedValue({
            html: '<div class="slide avian-background"><h1 class="avian-text">Test Slide</h1><p class="avian-text-secondary">Test content with AVIAN branding</p></div>',
            css: '.slide { background: #0A0A0A; color: #FFFFFF; } .avian-background { background-color: #0A0A0A !important; } .avian-text { color: #FFFFFF !important; } .avian-text-secondary { color: #B0B0B0 !important; }',
            metadata: {
                slideId: 'test-slide',
                slideType: 'summary',
                templateVersion: '1.0.0',
                renderTimestamp: new Date()
            }
        })
    }))
}));

// Mock ReportSnapshotService
jest.mock('../ReportSnapshotService', () => {
    const mockService = {
        updatePdfStorage: jest.fn().mockResolvedValue(undefined),
        getSnapshot: jest.fn().mockResolvedValue({
            id: 'test-snapshot-123',
            pdfStorageKey: 'reports/pdfs/test.pdf',
            pdfSize: 1000,
            generatedAt: new Date(),
            templateVersion: '1.0.0',
            dataSchemaVersion: '1.0.0'
        })
    };
    return {
        ReportSnapshotService: jest.fn().mockImplementation(() => mockService),
        reportSnapshotService: mockService
    };
});

// Mock Playwright with enhanced PDF generation
jest.mock('playwright', () => ({
    chromium: {
        launch: jest.fn().mockResolvedValue({
            newPage: jest.fn().mockResolvedValue({
                setContent: jest.fn().mockResolvedValue(undefined),
                waitForTimeout: jest.fn().mockResolvedValue(undefined),
                waitForLoadState: jest.fn().mockResolvedValue(undefined),
                evaluate: jest.fn().mockResolvedValue(undefined),
                addInitScript: jest.fn().mockResolvedValue(undefined),
                pdf: jest.fn().mockImplementation(() => {
                    // Generate a more realistic PDF with proper structure
                    const pdfContent = `%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
/Title (AVIAN Security Report - Weekly)
/Author (AVIAN Cybersecurity Platform)
/Subject (Weekly Security Report)
/Creator (AVIAN Reports Module)
/Producer (AVIAN PDF Generator v1.0.0)
>>
endobj
2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj
3 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 792 612]
/Resources <<
/Font <<
/F1 4 0 R
>>
>>
/Contents 5 0 R
>>
endobj
4 0 obj
<<
/Type /Font
/Subtype /Type1
/BaseFont /Helvetica
>>
endobj
5 0 obj
<<
/Length 200
>>
stream
BT
/F1 12 Tf
100 500 Td
(AVIAN Security Report) Tj
0 -20 Td
(Weekly Report - Test Content) Tj
0 -20 Td
(Generated by AVIAN Reports Module) Tj
0 -20 Td
(Landscape orientation preserved) Tj
0 -20 Td
(Dark theme with AVIAN branding) Tj
ET
endstream
endobj
xref
0 6
0000000000 65535 f 
0000000009 00000 n 
0000000200 00000 n 
0000000246 00000 n 
0000000380 00000 n 
0000000450 00000 n 
trailer
<<
/Size 6
/Root 1 0 R
>>
startxref
700
%%EOF`;
                    return Buffer.from(pdfContent);
                }),
                close: jest.fn().mockResolvedValue(undefined)
            }),
            close: jest.fn().mockResolvedValue(undefined),
            version: jest.fn().mockReturnValue('1.0.0')
        })
    }
}));

describe('PDFGenerator Property-Based Tests', () => {
    let pdfGenerator: PDFGenerator;

    // Shared generator for valid ReportSnapshot with correct types
    const validReportSnapshotGen = fc.record({
        id: fc.uuid(),
        tenantId: fc.uuid(),
        reportId: fc.uuid(),
        reportType: fc.constantFrom('weekly' as const, 'monthly' as const, 'quarterly' as const),
        dateRange: generators.enhancedDateRange,
        generatedAt: fc.date({ min: new Date('2024-01-01'), max: new Date('2024-12-31') }),
        generatedBy: fc.uuid(),
        slideData: fc.array(fc.record({
            slideId: fc.uuid(),
            slideType: fc.string({ minLength: 5, maxLength: 30 }),
            computedMetrics: fc.dictionary(fc.string(), fc.anything()),
            chartData: fc.array(fc.record({
                labels: fc.array(fc.string({ minLength: 1, maxLength: 20 }), { maxLength: 10 }),
                datasets: fc.array(fc.record({
                    label: fc.string({ minLength: 1, maxLength: 20 }),
                    data: fc.array(fc.nat({ max: 1000 }), { maxLength: 10 })
                }), { maxLength: 5 })
            }) as fc.Arbitrary<ChartData>, { maxLength: 5 }),
            templateData: fc.dictionary(fc.string(), fc.anything())
        }), { minLength: 1, maxLength: 10 }),
        templateVersion: fc.constant('1.0.0'),
        dataSchemaVersion: fc.constant('1.0.0'),
        pdfStorageKey: fc.option(fc.string({ minLength: 10, maxLength: 100 }), { nil: undefined }),
        pdfSize: fc.option(fc.nat({ max: 100000000 }), { nil: undefined }),
        isArchived: fc.boolean()
    });

    beforeEach(() => {
        pdfGenerator = new PDFGenerator();
        jest.clearAllMocks();
    });

    afterEach(async () => {
        await pdfGenerator.cleanup();
    });

    describe('Property 4: PDF Export Integrity', () => {
        /**
         * **Feature: avian-reports-module, Property 4: PDF export integrity**
         * **Validates: Requirements 8.1, 8.2, 8.3, 8.5**
         */
        it('should maintain visual formatting, charts, graphs, branding, and be client-ready for any report snapshot', async () => {
            await fc.assert(
                fc.asyncProperty(
                    validReportSnapshotGen,
                    async (snapshot: ReportSnapshot) => {
                        // Generate PDF from snapshot
                        const pdf = await pdfGenerator.exportToPDF(snapshot);

                        // Property: PDF should be a valid buffer with content
                        expect(pdf).toBeInstanceOf(Buffer);
                        expect(pdf.length).toBeGreaterThan(0);

                        // Property: PDF should have valid PDF structure (Requirement 8.1)
                        const pdfHeader = pdf.subarray(0, 8).toString('ascii');
                        expect(pdfHeader).toMatch(/^%PDF-/);

                        const pdfContent = pdf.toString('latin1');
                        expect(pdfContent).toContain('%%EOF');
                        expect(pdfContent).toContain('/Type /Catalog');
                        expect(pdfContent).toContain('/Type /Pages');

                        // Property: PDF should preserve AVIAN branding (Requirement 8.1, 8.2)
                        const hasBranding = [
                            'AVIAN',
                            'Security Report',
                            'Cybersecurity Platform',
                            'Reports Module'
                        ].some(brand => pdfContent.includes(brand));
                        expect(hasBranding).toBe(true);

                        // Property: PDF should maintain landscape orientation (Requirement 8.4)
                        const mediaBoxMatches = pdfContent.match(/\/MediaBox\s*\[\s*[\d\s.]+\]/g);
                        if (mediaBoxMatches && mediaBoxMatches.length > 0) {
                            const mediaBox = mediaBoxMatches[0];
                            const dimensions = mediaBox.match(/[\d.]+/g);
                            if (dimensions && dimensions.length >= 4) {
                                const width = parseFloat(dimensions[2]) - parseFloat(dimensions[0]);
                                const height = parseFloat(dimensions[3]) - parseFloat(dimensions[1]);
                                // Landscape: width should be greater than height
                                expect(width).toBeGreaterThan(height);
                            }
                        }

                        // Property: PDF should contain embedded fonts (Requirement 8.2)
                        const fontCount = (pdfContent.match(/\/Type \/Font/g) || []).length;
                        expect(fontCount).toBeGreaterThan(0);

                        // Property: PDF should be client-ready without manual editing (Requirement 8.3)
                        const validation = await pdfGenerator.validatePDFOutput(pdf);
                        expect(validation.isValid).toBe(true);

                        // Property: PDF should contain proper metadata for client delivery (Requirement 8.3)
                        const hasTitle = pdfContent.includes('/Title');
                        const hasAuthor = pdfContent.includes('/Author');
                        expect(hasTitle || hasAuthor).toBe(true);

                        // Property: PDF should maintain file integrity (Requirement 8.5)
                        const checksum1 = pdfGenerator.generateFileChecksum(pdf);
                        const checksum2 = pdfGenerator.generateFileChecksum(pdf);
                        expect(checksum1).toBe(checksum2);
                        expect(checksum1).toHaveLength(64); // SHA-256 hex string

                        // Property: PDF should be suitable for download and sharing (Requirement 8.5)
                        const downloadResponse = pdfGenerator.createDownloadResponse(pdf, `${snapshot.reportType}-report.pdf`);
                        expect(downloadResponse.buffer).toBe(pdf);
                        expect(downloadResponse.headers['Content-Type']).toBe('application/pdf');
                        expect(downloadResponse.headers['Content-Disposition']).toContain('attachment');
                        expect(downloadResponse.metadata.size).toBe(pdf.length);
                        expect(downloadResponse.metadata.mimeType).toBe('application/pdf');
                        expect(downloadResponse.metadata.checksum).toHaveLength(64);
                    }
                ),
                {
                    numRuns: 100,
                    timeout: 30000 // 30 seconds timeout for PDF generation
                }
            );
        });

        /**
         * **Feature: avian-reports-module, Property 4.1: PDF validation consistency**
         * **Validates: Requirements 8.1, 8.2, 8.3**
         */
        it('should consistently validate PDF quality across different report types and content', async () => {
            await fc.assert(
                fc.asyncProperty(
                    validReportSnapshotGen,
                    async (snapshot: ReportSnapshot) => {
                        // Generate PDF
                        const pdf = await pdfGenerator.exportToPDF(snapshot);

                        // Property: Validation should be consistent for the same PDF
                        const validation1 = await pdfGenerator.validatePDFOutput(pdf);
                        const validation2 = await pdfGenerator.validatePDFOutput(pdf);

                        expect(validation1.isValid).toBe(validation2.isValid);
                        expect(validation1.errors).toEqual(validation2.errors);
                        expect(validation1.warnings).toEqual(validation2.warnings);

                        // Property: Valid PDFs should pass all quality checks
                        if (validation1.isValid) {
                            expect(validation1.errors).toHaveLength(0);
                            expect(pdf.length).toBeGreaterThan(200); // Minimum reasonable size

                            const pdfContent = pdf.toString('latin1');
                            expect(pdfContent).toContain('%PDF-');
                            expect(pdfContent).toContain('%%EOF');
                        }

                        // Property: Invalid PDFs should have specific error messages
                        if (!validation1.isValid) {
                            expect(validation1.errors.length).toBeGreaterThan(0);
                            validation1.errors.forEach(error => {
                                expect(typeof error).toBe('string');
                                expect(error.length).toBeGreaterThan(0);
                            });
                        }
                    }
                ),
                {
                    numRuns: 100,
                    timeout: 30000
                }
            );
        });

        /**
         * **Feature: avian-reports-module, Property 4.2: PDF storage and retrieval integrity**
         * **Validates: Requirements 8.5**
         */
        it('should maintain PDF integrity through storage and retrieval operations', async () => {
            await fc.assert(
                fc.asyncProperty(
                    validReportSnapshotGen,
                    async (snapshot: ReportSnapshot) => {
                        // Generate PDF
                        const originalPdf = await pdfGenerator.exportToPDF(snapshot);
                        const originalChecksum = pdfGenerator.generateFileChecksum(originalPdf);

                        // Store PDF
                        const storageKey = await pdfGenerator.storePDF(originalPdf, snapshot.id);

                        // Property: Storage key should be valid
                        expect(typeof storageKey).toBe('string');
                        expect(storageKey.length).toBeGreaterThan(0);
                        expect(storageKey).toMatch(/^reports\/pdfs\/.*\.pdf$/);

                        // Retrieve PDF
                        const retrievedPdf = await pdfGenerator.retrievePDF(storageKey);

                        // Property: Retrieved PDF should be identical to original
                        expect(retrievedPdf).toEqual(originalPdf);
                        expect(retrievedPdf.length).toBe(originalPdf.length);

                        // Property: Checksums should match (integrity preserved)
                        const retrievedChecksum = pdfGenerator.generateFileChecksum(retrievedPdf);
                        expect(retrievedChecksum).toBe(originalChecksum);

                        // Property: File integrity verification should pass
                        const integrityCheck = pdfGenerator.verifyFileIntegrity(retrievedPdf, originalChecksum);
                        expect(integrityCheck).toBe(true);

                        // Clean up
                        await pdfGenerator.deletePDF(storageKey);
                    }
                ),
                {
                    numRuns: 50, // Reduced runs for file I/O operations
                    timeout: 45000 // Longer timeout for file operations
                }
            );
        });

        /**
         * **Feature: avian-reports-module, Property 4.3: PDF export reproducibility**
         * **Validates: Requirements 8.1, 8.2, 9.2**
         */
        it('should generate identical PDFs from the same snapshot data', async () => {
            await fc.assert(
                fc.asyncProperty(
                    validReportSnapshotGen,
                    async (snapshot: ReportSnapshot) => {
                        // Generate PDF twice from the same snapshot
                        const pdf1 = await pdfGenerator.exportToPDF(snapshot);
                        const pdf2 = await pdfGenerator.exportToPDF(snapshot);

                        // Property: PDFs should have identical structure and content
                        expect(pdf1.length).toBe(pdf2.length);

                        // Property: Checksums should be identical (reproducibility)
                        const checksum1 = pdfGenerator.generateFileChecksum(pdf1);
                        const checksum2 = pdfGenerator.generateFileChecksum(pdf2);
                        expect(checksum1).toBe(checksum2);

                        // Property: Both PDFs should pass validation identically
                        const validation1 = await pdfGenerator.validatePDFOutput(pdf1);
                        const validation2 = await pdfGenerator.validatePDFOutput(pdf2);
                        expect(validation1.isValid).toBe(validation2.isValid);
                        expect(validation1.errors).toEqual(validation2.errors);

                        // Property: PDF content should be structurally identical
                        const content1 = pdf1.toString('latin1');
                        const content2 = pdf2.toString('latin1');

                        // Check key structural elements are identical
                        const extractStructure = (content: string) => ({
                            hasHeader: content.includes('%PDF-'),
                            hasEOF: content.includes('%%EOF'),
                            hasCatalog: content.includes('/Type /Catalog'),
                            hasPages: content.includes('/Type /Pages'),
                            fontCount: (content.match(/\/Type \/Font/g) || []).length,
                            pageCount: (content.match(/\/Type \/Page[^s]/g) || []).length
                        });

                        const structure1 = extractStructure(content1);
                        const structure2 = extractStructure(content2);
                        expect(structure1).toEqual(structure2);
                    }
                ),
                {
                    numRuns: 50, // Reduced runs for reproducibility testing
                    timeout: 60000 // Longer timeout for multiple PDF generations
                }
            );
        });

        /**
         * **Feature: avian-reports-module, Property 4.4: PDF metadata preservation**
         * **Validates: Requirements 8.1, 8.3**
         */
        it('should preserve all required metadata in generated PDFs', async () => {
            await fc.assert(
                fc.asyncProperty(
                    validReportSnapshotGen,
                    fc.record({
                        title: fc.string({ minLength: 5, maxLength: 100 }),
                        author: fc.string({ minLength: 5, maxLength: 50 }),
                        subject: fc.string({ minLength: 10, maxLength: 200 })
                    }),
                    async (snapshot: ReportSnapshot, metadata) => {
                        // Generate PDF with custom metadata
                        const pdf = await pdfGenerator.exportToPDF(snapshot, {}, metadata);

                        const pdfContent = pdf.toString('latin1');

                        // Property: PDF should contain the specified metadata
                        if (metadata.title) {
                            expect(pdfContent).toContain('/Title');
                        }
                        if (metadata.author) {
                            expect(pdfContent).toContain('/Author');
                        }
                        if (metadata.subject) {
                            expect(pdfContent).toContain('/Subject');
                        }

                        // Property: PDF should contain AVIAN-specific metadata
                        const avianMetadataPresent = [
                            '/Creator',
                            '/Producer',
                            'AVIAN'
                        ].some(meta => pdfContent.includes(meta));
                        expect(avianMetadataPresent).toBe(true);

                        // Property: PDF should be client-ready with proper metadata
                        const validation = await pdfGenerator.validatePDFOutput(pdf);
                        expect(validation.isValid).toBe(true);

                        // Property: Download response should include metadata
                        const downloadResponse = pdfGenerator.createDownloadResponse(pdf, 'test-report.pdf');
                        expect(downloadResponse.headers['X-Generated-By']).toBe('AVIAN Reports Module');
                        expect(downloadResponse.headers['X-File-Checksum']).toBeDefined();
                        expect(downloadResponse.metadata.checksum).toHaveLength(64);
                    }
                ),
                {
                    numRuns: 100,
                    timeout: 30000
                }
            );
        });
    });

    describe('Edge Cases and Error Handling', () => {
        /**
         * **Feature: avian-reports-module, Property 4.5: PDF validation error detection**
         * **Validates: Requirements 8.3**
         */
        it('should correctly identify invalid PDF structures', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.oneof(
                        fc.constant(Buffer.alloc(0)), // Empty buffer
                        fc.constant(Buffer.from('Not a PDF')), // Invalid content
                        fc.constant(Buffer.from('%PDF-1.4\nIncomplete')), // Truncated PDF
                        fc.uint8Array({ minLength: 1, maxLength: 100 }).map(arr => Buffer.from(arr)) // Random bytes
                    ),
                    async (invalidPdf: Buffer) => {
                        // Property: Invalid PDFs should be detected by validation
                        const validation = await pdfGenerator.validatePDFOutput(invalidPdf);
                        expect(validation.isValid).toBe(false);
                        expect(validation.errors.length).toBeGreaterThan(0);

                        // Property: Error messages should be descriptive
                        validation.errors.forEach(error => {
                            expect(typeof error).toBe('string');
                            expect(error.length).toBeGreaterThan(0);
                        });

                        // Property: Specific error types should be detected
                        const errorText = validation.errors.join(' ').toLowerCase();
                        const hasRelevantError = [
                            'empty',
                            'null',
                            'invalid',
                            'header',
                            'corrupted',
                            'small',
                            'truncated'
                        ].some(keyword => errorText.includes(keyword));
                        expect(hasRelevantError).toBe(true);
                    }
                ),
                {
                    numRuns: 100,
                    timeout: 15000
                }
            );
        });
    });
});