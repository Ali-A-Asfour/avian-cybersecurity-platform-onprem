import { NextRequest, NextResponse } from 'next/server';
import { authMiddleware } from '@/middleware/auth.middleware';
import { tenantMiddleware } from '@/middleware/tenant.middleware';
// import { logger } from '@/lib/logger';
import { ApiResponse, AlertSeverity } from '@/types';

interface RouteParams {
  params: Promise<{
    id: string;
  }>;
}

export async function GET(request: NextRequest, { params }: RouteParams) {
  const { id: _id } = await params;
  try {
    // Apply authentication and tenant middleware
    const authResult = await authMiddleware(request);
    if (authResult instanceof NextResponse) {
      return authResult;
    }

    const tenantResult = await tenantMiddleware(request, authResult.user);
    if (tenantResult instanceof NextResponse) {
      return tenantResult;
    }

    const { user, tenant } = tenantResult;
    const _agentId = params.id;

    // Only Security Analysts, Tenant Admins, and Super Admins can view agent alerts
    if (!['super_admin', 'tenant_admin', 'security_analyst'].includes(user.role)) {
      const response: ApiResponse = {
        success: false,
        error: {
          code: 'INSUFFICIENT_PERMISSIONS',
          message: 'Insufficient permissions to view agent alerts',
        },
      };
      return NextResponse.json(response, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const _timeRange = searchParams.get('time_range') || '24h';
    const severity = searchParams.get('severity');
    const status = searchParams.get('status');

    // Get alerts generated by this agent
    const alerts = await getAgentAlerts(agentId, timeRange, severity, status);

    const response: ApiResponse = {
      success: true,
      data: alerts,
    };

    return NextResponse.json(response);
  } catch {
    logger.error('Failed to get agent alerts', { error, agentId: params.id });
    
    const response: ApiResponse = {
      success: false,
      error: {
        code: 'AGENT_ALERTS_ERROR',
        message: 'Failed to retrieve agent alerts',
      },
    };

    return NextResponse.json(response, { status: 500 });
  }
}

export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    // Apply authentication and tenant middleware
    const authResult = await authMiddleware(request);
    if (authResult instanceof NextResponse) {
      return authResult;
    }

    const tenantResult = await tenantMiddleware(request, authResult.user);
    if (tenantResult instanceof NextResponse) {
      return tenantResult;
    }

    const { user, tenant } = tenantResult;
    const _agentId = params.id;

    // Only Security Analysts, Tenant Admins, and Super Admins can create agent alerts
    if (!['super_admin', 'tenant_admin', 'security_analyst'].includes(user.role)) {
      const response: ApiResponse = {
        success: false,
        error: {
          code: 'INSUFFICIENT_PERMISSIONS',
          message: 'Insufficient permissions to create agent alerts',
        },
      };
      return NextResponse.json(response, { status: 403 });
    }

    const alertRequest = await request.json();

    // Validate alert request
    if (!alertRequest.event_data || !alertRequest.alert_type) {
      const response: ApiResponse = {
        success: false,
        error: {
          code: 'INVALID_ALERT_REQUEST',
          message: 'Event data and alert type are required',
        },
      };
      return NextResponse.json(response, { status: 400 });
    }

    // Create alert from agent data
    const alert = await createAgentAlert(agentId, tenant.id, alertRequest, user.id);

    const response: ApiResponse = {
      success: true,
      data: alert,
    };

    return NextResponse.json(response);
  } catch {
    logger.error('Failed to create agent alert', { error, agentId: params.id });
    
    const response: ApiResponse = {
      success: false,
      error: {
        code: 'AGENT_ALERT_CREATION_ERROR',
        message: 'Failed to create agent alert',
      },
    };

    return NextResponse.json(response, { status: 500 });
  }
}

async function getAgentAlerts(agentId: string, timeRange: string, severity?: string, status?: string): Promise<any> {
  // In a real implementation, this would query the alerts database
  // For now, return mock data
  const mockAlerts = {
    agent_id: agentId,
    time_range: timeRange,
    total_alerts: 15,
    alerts: [
      {
        id: 'alert-agent-1',
        title: 'Suspicious Network Connection Detected',
        description: 'Agent detected connection to known malicious IP address',
        severity: AlertSeverity.HIGH,
        status: 'open',
        source: 'avian_agent',
        source_id: agentId,
        category: 'network_security',
        metadata: {
          remote_ip: '192.168.1.100',
          remote_port: 4444,
          process_name: 'suspicious.exe',
          threat_indicators: ['malicious_ip', 'unusual_port'],
        },
        created_at: new Date(Date.now() - 1800000), // 30 minutes ago
        updated_at: new Date(Date.now() - 1800000),
      },
      {
        id: 'alert-agent-2',
        title: 'Anomalous System Performance',
        description: 'Unusual CPU and memory usage patterns detected',
        severity: AlertSeverity.MEDIUM,
        status: 'investigating',
        source: 'avian_agent',
        source_id: agentId,
        category: 'performance_anomaly',
        metadata: {
          cpu_usage: 95.2,
          memory_usage: 89.7,
          duration_minutes: 15,
          anomaly_score: 0.87,
        },
        created_at: new Date(Date.now() - 3600000), // 1 hour ago
        updated_at: new Date(Date.now() - 1800000), // 30 minutes ago
      },
      {
        id: 'alert-agent-3',
        title: 'Unauthorized File Modification',
        description: 'Critical system file modified by unauthorized process',
        severity: AlertSeverity.CRITICAL,
        status: 'escalated',
        source: 'avian_agent',
        source_id: agentId,
        category: 'file_integrity',
        metadata: {
          file_path: '/etc/passwd',
          process_name: 'unknown_process',
          user_account: 'root',
          modification_type: 'content_changed',
        },
        created_at: new Date(Date.now() - 7200000), // 2 hours ago
        updated_at: new Date(Date.now() - 3600000), // 1 hour ago
      },
      {
        id: 'alert-agent-4',
        title: 'Malware Signature Detected',
        description: 'Known malware signature found in file system scan',
        severity: AlertSeverity.CRITICAL,
        status: 'resolved',
        source: 'avian_agent',
        source_id: agentId,
        category: 'malware_detection',
        metadata: {
          file_path: '/tmp/malicious_file.exe',
          malware_family: 'Trojan.Generic',
          hash_sha256: 'a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456',
          action_taken: 'quarantined',
        },
        created_at: new Date(Date.now() - 10800000), // 3 hours ago
        updated_at: new Date(Date.now() - 7200000), // 2 hours ago
      },
      {
        id: 'alert-agent-5',
        title: 'Privilege Escalation Attempt',
        description: 'Process attempted to escalate privileges without authorization',
        severity: AlertSeverity.HIGH,
        status: 'open',
        source: 'avian_agent',
        source_id: agentId,
        category: 'privilege_escalation',
        metadata: {
          process_name: 'exploit.exe',
          user_account: 'limited_user',
          target_privilege: 'administrator',
          escalation_method: 'token_manipulation',
        },
        created_at: new Date(Date.now() - 14400000), // 4 hours ago
        updated_at: new Date(Date.now() - 14400000),
      },
    ],
    summary: {
      critical_alerts: 2,
      high_alerts: 2,
      medium_alerts: 1,
      low_alerts: 0,
      open_alerts: 3,
      investigating_alerts: 1,
      resolved_alerts: 1,
    },
  };

  // Apply filters
  if (severity) {
    mockAlerts.alerts = mockAlerts.alerts.filter(alert => alert.severity === severity);
  }

  if (status) {
    mockAlerts.alerts = mockAlerts.alerts.filter(alert => alert.status === status);
  }

  return mockAlerts;
}

async function createAgentAlert(agentId: string, tenantId: string, alertRequest: any, createdBy: string): Promise<any> {
  const alert = {
    id: `alert-agent-${Date.now()}`,
    title: alertRequest.title || 'Agent Generated Alert',
    description: alertRequest.description || 'Alert generated by AVIAN agent',
    severity: alertRequest.severity || AlertSeverity.MEDIUM,
    status: 'open',
    source: 'avian_agent',
    source_id: agentId,
    tenant_id: tenantId,
    category: alertRequest.alert_type,
    metadata: {
      ...alertRequest.event_data,
      created_by: createdBy,
      agent_id: agentId,
    },
    created_at: new Date(),
    updated_at: new Date(),
  };

  // In a real implementation, this would be stored in the database
  logger.info('Agent alert created', { 
    alertId: alert.id,
    agentId,
    tenantId,
    severity: alert.severity,
    category: alert.category
  });

  return alert;
}